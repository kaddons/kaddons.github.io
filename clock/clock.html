<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Time & Date & Weather with Geolocation</title>
<style>
  /* Your existing styles here (unchanged) */
  body {
    margin: 0;
    padding-bottom: 160px;
    background-color: black;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: dimgray;
  }

  #header {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  #analogClock {
    width: 250px;
    height: 250px;
  }

  #time {
    font-size: clamp(4rem, 10vw, 8rem);
    display: flex;
    align-items: baseline;
    margin-top: -9vh;
  }
  #time span {
    display: inline-block;
  }
  #time .normal-colon {
    font-size: 1em;
  }
  #time .small-colon {
    font-size: 0.5em;
    margin: 0 0.2em;
  }
  #seconds {
    font-size: 0.7em;
  }
  #ampm {
    font-size: 0.5em;
    margin-left: 0.2em;
  }

  #date {
    font-size: clamp(1.2rem, 3vw, 2rem);
    margin-top: 2vh;
    text-align: center;
  }

  #weather-container {
    width: 100%;
    padding: 10px 20px;
    box-sizing: border-box;
    background: #000;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: flex-start;
    gap: 10px;
  }

  #column {
    flex: 0 0 100%;
    display: flex;
    flex-direction: column;
  }

  #location-info {
    margin-top: 30px;
    align-items: center;
    text-align: center;
  }
  #location {
    font-weight: bold;
    font-size: 1.2em;
  }
  #month-year {
    font-size: 0.9em;
  }

  #forecast-container {
    display: flex;
    gap: 10px;
    overflow-x: auto;
    justify-content: center;
  }
  .day {
    text-align: center;
    min-width: 80px;
  }
  .icon {
    width: 40px;
    height: 40px;
    display: block;
    margin: 0 auto 5px auto;
    box-shadow: 2px 2px 8px rgba(0,0,0,0.8);
    border-radius: 4px;
  }

  @media(max-width: 768px){
    #analogClock {
      width: 200px;
      height: 200px;
    }
    #weather-container {
      flex-direction: column;
    }
    #forecast-container {
      margin-top: 10px;
    }
  }
</style>
</head>
<body>
  <!-- Header: clock + date -->
  <div id="header">
    <canvas id="analogClock" width="250" height="250"></canvas>
    <div id="time">
      <span id="hours">Loading</span>
      <span class="normal-colon">:</span>
      <span id="minutes">Loading</span>
      <span class="small-colon">:</span>
      <span id="seconds">Loading</span>
      <span id="ampm">AM</span>
    </div>
    <div id="date">Loading...</div>
  </div>

  <!-- Weather-->
  <div id="weather-container">
    <div id="column" class="column">
      <div id="forecast-container">
        <div id="location-info">
          <div id="location">Loading...</div>
          <div id="month-year"></div>
        </div>
        <div class="day" id="day1"></div>
        <div class="day" id="day2"></div>
        <div class="day" id="day3"></div>
        <div class="day" id="day4"></div>
        <div class="day" id="day5"></div>
      </div>
    </div>
  </div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // === clock functions and fade effects (unchanged) ===
    const body = document.body;
    let fadeInitiated = false;

    function fadeOut() {
      return new Promise((resolve) => {
        body.style.transition = 'opacity 3s ease-in-out';
        body.style.opacity = 0;
        setTimeout(resolve, 3000);
      });
    }
    function fadeIn() {
      return new Promise((resolve) => {
        body.style.transition = 'opacity 3s ease-in-out';
        body.style.opacity = 1;
        setTimeout(resolve, 3000);
      });
    }
    async function handleFadeCycle() {
      await fadeOut();
      updateClock();
      await fadeIn();
    }

    const canvas = document.getElementById('analogClock');
    const ctx = canvas.getContext('2d');
    const radius = 100; // half of width/height

    function drawClock() {
      const now = new Date();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      ctx.arc(radius, radius, radius - 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'dimgray';
      ctx.lineWidth = 4;
      ctx.stroke();

      for (let i = 0; i < 60; i++) {
        if (i % 5 !== 0) continue;
        const angle = (i * Math.PI) / 30;
        let innerRadius = radius - 25;
        let outerRadius = radius - 9;
        if (i % 15 === 0) {
          innerRadius = radius - 30;
          outerRadius = radius - 9;
        }
        ctx.lineWidth = i % 15 === 0 ? 5 : 3;
        ctx.strokeStyle = 'dimgray';
        ctx.beginPath();
        ctx.moveTo(
          radius + Math.cos(angle - Math.PI / 2) * innerRadius,
          radius + Math.sin(angle - Math.PI / 2) * innerRadius
        );
        ctx.lineTo(
          radius + Math.cos(angle - Math.PI / 2) * outerRadius,
          radius + Math.sin(angle - Math.PI / 2) * outerRadius
        );
        ctx.stroke();
      }

      for (let i = 0; i < 60; i++) {
        if (i % 5 === 0) continue;
        const angle = (i * Math.PI) / 30;
        const innerRadius = radius - 20;
        const outerRadius = radius - 12;
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'dimgray';
        ctx.beginPath();
        ctx.moveTo(
          radius + Math.cos(angle - Math.PI / 2) * innerRadius,
          radius + Math.sin(angle - Math.PI / 2) * innerRadius
        );
        ctx.lineTo(
          radius + Math.cos(angle - Math.PI / 2) * outerRadius,
          radius + Math.sin(angle - Math.PI / 2) * outerRadius
        );
        ctx.stroke();
      }

      const seconds = now.getSeconds();
      const minutes = now.getMinutes();
      const hours = now.getHours();
      const secondAngle = (seconds * Math.PI) / 30;
      const minuteAngle = (minutes * Math.PI) / 30 + (secondAngle / 60);
      const hourAngle = ((hours % 12) + minutes / 60) * (Math.PI / 6);

      ctx.lineWidth = 6;
      ctx.strokeStyle = 'dimgray';
      ctx.beginPath();
      ctx.moveTo(radius, radius);
      ctx.lineTo(
        radius + Math.cos(hourAngle - Math.PI / 2) * (radius - 60),
        radius + Math.sin(hourAngle - Math.PI / 2) * (radius - 60)
      );
      ctx.stroke();

      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(radius, radius);
      ctx.lineTo(
        radius + Math.cos(minuteAngle - Math.PI / 2) * (radius - 40),
        radius + Math.sin(minuteAngle - Math.PI / 2) * (radius - 40)
      );
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.strokeStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(radius, radius);
      ctx.lineTo(
        radius + Math.cos(secondAngle - Math.PI / 2) * (radius - 20),
        radius + Math.sin(secondAngle - Math.PI / 2) * (radius - 20)
      );
      ctx.stroke();
    }

    function updateClock() {
      const now = new Date();
      let hours = now.getHours();
      const minutes = now.getMinutes();
      const seconds = now.getSeconds();
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12 || 12;

      document.getElementById('hours').textContent = hours;
      document.getElementById('minutes').textContent = String(minutes).padStart(2, '0');
      document.getElementById('seconds').textContent = String(seconds).padStart(2, '0');
      document.getElementById('ampm').textContent = ampm;

      const days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      const dayName = days[now.getDay()];
      const day = now.getDate();
      const month = months[now.getMonth()];
      const year = now.getFullYear();

      function getOrdinal(n) { if (n > 3 && n < 21) return 'th'; switch (n % 10) { case 1: return 'st'; case 2: return 'nd'; case 3: return 'rd'; default: return 'th'; } }

      const dateString = `${dayName} ${day}${getOrdinal(day)} ${month} ${year}`;
      document.getElementById('date').textContent = dateString;

      drawClock();

      if (seconds === 57 && !fadeInitiated) {
        fadeInitiated = true;
        handleFadeCycle().then(() => { fadeInitiated = false; });
      }
    }
    setInterval(updateClock, 1000);
    updateClock();

    // === Weather fetching with geolocation ===
    const apiKey='47c1af6a7c3a2323766a8d053389d54e';

    function getIconUrl(iconCode) {
      return `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
    }

    async function fetchForecast(lat, lon) {
      const url=`https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`;
      try {
        const response=await fetch(url);
        if (!response.ok) throw new Error('Network response not ok');
        const data=await response.json();

        // Append ", UK" to the location name
        const locationName = data.city.name || 'Location';
        const displayName = locationName + ', UK';
        document.getElementById('location').textContent=displayName;

        const now=new Date();
        const optionsMonthYear={ year:'numeric', month:'long' };
        document.getElementById('month-year').textContent=now.toLocaleDateString(undefined, optionsMonthYear);

        const forecastByDate={};
        data.list.forEach(entry=>{
          const dateObj=new Date(entry.dt*1000);
          const options={weekday:'short'};
          const dayName=dateObj.toLocaleDateString(undefined, options);
          const dayNumber=dateObj.getDate();
          const key=dateObj.toDateString();
          if(!forecastByDate[key]) forecastByDate[key]={ dayName, dayNumber, entries:[] };
          forecastByDate[key].entries.push(entry);
        });

        const dates=Object.keys(forecastByDate).slice(0,5);
        for(let i=0;i<5;i++){
          const dateKey=dates[i];
          if(!dateKey){
            document.getElementById(`day${i+1}`).innerHTML=`<div>No data</div>`;
            continue;
          }
          const { dayName, dayNumber, entries }=forecastByDate[dateKey];
          const temps=entries.map(e=>e.main.temp);
          const avgTemp=Math.round(temps.reduce((a,b)=>a+b,0)/temps.length);
          const midEntry=entries[Math.floor(entries.length/2)];
          const iconCode=midEntry.weather[0].icon;
          const description=midEntry.weather[0].description;

          document.getElementById(`day${i+1}`).innerHTML=`
            <div><strong>${dayNumber} ${dayName}</strong></div>
            <img class="icon" src="${getIconUrl(iconCode)}" alt="${description}">
            <div>${avgTemp}°C</div>
          `;
        }
      } catch(e){
        console.error('Error fetching weather:', e);
      }
    }

    // Initiate geolocation
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Got geolocation:", position);
          const { latitude, longitude } = position.coords;
          fetchForecast(latitude, longitude);
        },
        (error) => {
          console.warn("Geolocation failed or denied. Using default location.");
          fetchForecast(51.5085, -0.1257); // default coords
        }
      );
    } else {
      console.warn("Geolocation not supported. Using default location.");
      fetchForecast(51.5085, -0.1257);
    }
  });
</script>
</body>
</html>
